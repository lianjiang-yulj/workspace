#!/bin/bash
#
copyright_notice="Copyright (C) 1987-2014 Intel Corporation. All rights reserved."
#
package_name="Intel(R) Software License Manager"
#
package_attr="*Other names and brands may be claimed as the property of others."
# 
#
# This software is furnished under a license and may be used and copied
# only  in  accordance  with  the  terms  of  such license and with the
# inclusion of the above copyright notice. This software or  any  other
# copies thereof may not be provided or otherwise made available to any
# other person.  No title to and ownership of  the  software is  hereby
# transferred.  The information in  this  software is subject to change
# without notice.

#
# Manifest constants.
#

support_www="http://software.intel.com/sites/support/"

name_script="Install_INTEL"

name_lmgrd="lmgrd"
name_vendor="INTEL"
name_vendor_actlib="INTEL_libFNP.so"
name_lmutil="lmutil"
name_chklic="chklic"
name_chklic_actlib="chklic_libFNP.so"
name_getip="getip"
name_readme="README"
name_eula="END_USER_LICENSE"
name_howto="HowTo.html"
name_enduser="fnp_LicAdmin.pdf"
# see get_install_file_mode() to get the right chmod mode for each of $all_files
all_files="$name_lmutil $name_script $name_lmgrd $name_vendor $name_vendor_actlib $name_howto $name_readme $name_eula $name_enduser $name_getip $name_chklic $name_chklic_actlib"

name_lmstat=lmstat
name_lmreread=lmreread
all_links=("$name_lmreread" "$name_lmstat" lmdiag lmdown lmhostid lminstall lmremove lmswitchr lmver lmpath lmborrow lmswitch lmnewlog)
dir_inst_lic="/opt/intel/licenses"
dir_tmpdir_subdir="${name_script}.$$.dir"
file_inst_lic="server.lic"
file_local_lic="server.lic"
file_temp="${name_script}.$$.tmp"
file_temp_wdtest="${name_script}.$$.tmp2"
file_log="${name_script}.log"
file_server_log="${name_lmgrd}.log"
file_rc="${name_lmgrd}.rc"
file_cfg="${name_script}.cfg"

tag="***"

do_work=true
verbose_command=
assume_server_lic=
interrupt_exit_enabled=true
dir_inst_files_is=current

# constant: if true, do screen_install_lic_file: enable copying licenses to $dir_inst_lic (/opt/intel/licenses)
do_dir_inst_lic=
# constant: if true, execute $file_rc directly to start server during installation
do_start_file_rc=true

echo_header()
{
    echo
    echo "--------------------------------------------------------------------------------"
}

#
# Setup things that have to be done right away.
#

umask 022
my_script_name="$0"
start_date=`date`
trap 'int_handler' INT

# Like parse_arguments but for certain switches that need to be read early.
pre_parse_arguments()
{
    while [ $# -gt 0 ]; do
        arg="$1"
        if [ -n "$arg" ]; then
            case "$arg" in
                -nowork )          do_work= ; verbose_command=true ;;
                -verbose )         do_work=true ; verbose_command=true ;;
                * )                ;;
            esac
        fi
        shift
    done
}

# $1 = file with possible absolute or relative path
# returns:
#     $file_dir with directory containing the file (with no / at the end)
#         (NOTE: $file_dir can be absolute or relative)
#     $file_name with just the filename part (with no / at the beginning)
#     anything illegal, empty, etc. returns an empty file_dir
#         (good idea to not call this if ! -f $1, though)
#     anything in . returns file_dir=.
#     anything in .. returns file_dir=..
#     anything relative returns file_dir starting with ./ or ../
#     anything absolute returns file_dir starting with /
get_file_directory_name()
{
    file_dir=
    file_name=

    if [ -z "$1" ]; then return; fi
    case "$1" in
        / | . | .. ) return ;;
        /*/* )       dirnam="$1" ;;
        /* )
            file_dir="/"
            file_name=`echo "$1" | sed -e 's/^\///'`
            return
            ;;
        ./* )        dirnam="$1"   ;;
        ../* )       dirnam="$1"   ;;
        * )          dirnam="./$1" ;;
    esac

    file_dir=`echo "$dirnam" | sed -e 's/\/[^/]*$//'`
    file_name=`echo "$dirnam" | sed -e 's/^.*\///'`
}

# Like run_command_dev_null but no $file_log and no my_exit.
# $1   = error message to use on failure (if is "", return silently on failure rather than exiting noisily)
# $2.. = command string to run
# $failed = returned on failure
# if $verbose_command is set the command will be printed before being executed
# if $do_work is not set the command won't actually be executed
run_command_dev_null_nolog()
{
    local errinfo="$1"
    shift
    failed=
    if [ -n "$verbose_command" ]; then echo "$tag $@"; fi
    if [ -n "$do_work" ]; then
        "$@" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
            failed=true
            if [ -n "$errinfo" ]; then
                echo "$tag Error: $errinfo"
                echo "$tag Command: $@ > /dev/null 2>&1"
                # Not my_exit; too early in script
                exit 1
            fi
        fi
    fi
}

# Like run_command_cd but no $file_log and no my_exit.
# $1 = directory to cd to
# $2 = error message to use on failure
# $failed = returned on failure
# if $verbose_command is set the command will be printed before being executed
# if $do_work is not set the command won't actually be executed
run_command_cd_nolog()
{
    local errinfo="$1"
    shift

    if [ -n "$verbose_command" ]; then echo "$tag cd $@"; fi
    if [ -n "$do_work" ]; then
        if [ -d "$@" ]; then
            cd "$@"
        else
            echo "$tag Error: $errinfo"
            echo "$tag Command: cd $@"
            # Not my_exit; too early in script
            exit 1
            failed=true
        fi
    else
        failed=
    fi
}

# See if $1 is a writable directory.  Return failed=true if it is not.
# $1 = name of directory we hope is writable
# $2 = name of test directory to try to create (helps check for name clashes)
check_if_writable_dir()
{
    if [ -z "$2" ]; then
        echo "$tag Internal Error: not enough arguments to check_if_writable_dir"
        failed=true
        return
    fi
    if [ -d "$1" ]; then
        if [ -w "$1" ]; then
            # It might not really be writable.  The -w test will pass in a readonly directory
            # or even on a readonly filesystem (e.g., CDROM) if you are root.  Test and see.
            run_command_dev_null_nolog "" mkdir "$1/$2"
            if [ -z "$failed" ]; then
                run_command_dev_null_nolog "" rmdir "$1/$2"
                # We'll assume everything is ok if the mkdir and the rmdir both succeed.
            fi
        else
            failed=true
        fi
    else
        failed=true
    fi
}

set_up_tmpdir()
{
    for i in "$TMPDIR" "$TEMP" "$TMP" /tmp /var/tmp /usr/tmp; do
        check_if_writable_dir "$i" "$file_temp_wdtest"
        if [ -z "$failed" ]; then
            TMPDIR="$i"
            return
        fi
    done
    echo "$tag Error: could not find a temporary directory to use (and TMPDIR, TEMP, TMP environment variables not set)"
    # Not my_exit; too early in script
    exit 1
}

set_up_pwdcmd()
{
    for i in `which pwd 2> /dev/null` /bin/pwd /usr/ucb/pwd; do
        if [ -f "$i" -a -x "$i" ]; then
            PWDCMD="$i"
            return
        fi
    done
    PWDCMD="pwd"
}

# If $1 == $name_chklic we might have to do special processing on it.  This is because
# this installer can be run inside an Intel Linux compiler install.  In that case, it
# is possible that $name_chklic does not exist but ../chklic.{32,64} do.  This whole business
# could be skipped (just return special_chklic=) if we could verify that the installer
# was not being invoked from within a Linux Intel compiler install.
# $1 = filename (one of $all_files)
# $special_chklic = path/name of chklic file found in Intel compiler installer, if applicable
special_chklic_processing()
{
    special_chklic=
    case "$1" in
        $name_chklic )
            if [ -f "$dir_inst_files/$1" ]; then
                return  # we've got the file in the usual place we expected; no action required
            fi
            uname=`uname`
            case "$uname" in
                Linux )
                    unamem=`uname -m`
                    case "$unamem" in
                        ia64 )
                            special_chklic="$1"
                            special_chklic="$dir_inst_files/../${special_chklic}.64"
                            if [ -f "$special_chklic" ]; then
                                return  # we've got something we can use, just with the wrong location/name
                            fi
                        ;;
                        * )
                            special_chklic="$1"
                            special_chklic="$dir_inst_files/../${special_chklic}.32"
                            if [ -f "$special_chklic" ]; then
                                return  # we've got something we can use, just with the wrong location/name
                            fi
                        ;;
                    esac
                    # we didn't find a suitable chklic anywhere
                    special_chklic=
                ;;
                * ) ;;  # nothing to do here, not Linux
            esac
        ;;
        * ) ;;  # nothing to do here, not chklic
    esac
}

echo_version()
{
    echo "$tag $my_script_name, version 11.12.0 / $cvs_id"
}

# Do this right away so everything below can handle -verbose or -nowork.
pre_parse_arguments "$@"

# Figure out where the user really was when he invoked the installer.
set_up_pwdcmd
dir_orig=`$PWDCMD`
dir_inst_files="$dir_orig"

# This is required so we can find the rest of the installation files.  See places in code that say:
# Expect $name_script and $all_files to be in $dir_inst_files, the directory where we were when we ran $name_script.
get_file_directory_name "$my_script_name"
if [ -z "$file_dir" ]; then
    echo "$tag Error: could not determine directory path from command name: $my_script_name"
    # Not my_exit; too early in script
    exit 1
fi
if [ "$file_dir" != "." ]; then
    # make sure that $dir_inst_files is always an absolute path
    if [ -n "`echo "$file_dir" | sed -e '/^\//d'`" ]; then
        file_dir="$dir_orig/$file_dir"
    fi
    dir_inst_files="$file_dir"
    dir_inst_files_is=install
fi

# Have to make sure we are working in a writable directory before we even
# start off the log file.  We need write access for $file_log, $file_cfg,
# and for the chmod done in setup().
set_up_tmpdir
check_if_writable_dir "$dir_inst_files" "$file_temp_wdtest"
if [ -n "$failed" ]; then
    # This can happen if the files are on a CDROM or a read-only filesystem.
    # To work around this, we pre-copy all the files to $TMPDIR/$dir_tmpdir_subdir and then go from there
    # as though we untarred the package in $TMPDIR/$dir_tmpdir_subdir in the first place.

    dir_inst_files_is=temporary

    # No run_command_dev_null_nolog here; just try as hard as possible to erase, _if_ it exists
    /bin/rm -rf "$TMPDIR/$dir_tmpdir_subdir" > /dev/null 2>&1

    run_command_dev_null_nolog "could not create $dir_inst_files_is directory" mkdir "$TMPDIR/$dir_tmpdir_subdir"

    # Expect $name_script and $all_files to be in $dir_inst_files, the directory where we were when we ran $name_script.
    # Copy them all to a writable $TMPDIR/$dir_tmpdir_subdir so we can continue from there.
    for i in $all_files; do
        special_chklic_processing "$i"
        if [ -n "$special_chklic" ]; then
            run_command_dev_null_nolog "could not copy file to $dir_inst_files_is directory" /bin/cp "$special_chklic" "$TMPDIR/$dir_tmpdir_subdir/$i"
        else
            if [ ! -f "$dir_inst_files/$i" ]; then
                echo "$tag Error: could not find installation file: $dir_inst_files/$i"
                # Not my_exit; too early in script
                exit 1
            fi
            run_command_dev_null_nolog "could not copy file to $dir_inst_files_is directory" /bin/cp "$dir_inst_files/$i" "$TMPDIR/$dir_tmpdir_subdir/$i"
        fi
    done

    dir_inst_files="$TMPDIR/$dir_tmpdir_subdir"
fi
check_if_writable_dir "$dir_inst_files" "$file_temp_wdtest"
if [ -n "$failed" ]; then
    echo "$tag Error: cannot write to $dir_inst_files_is directory: $dir_inst_files"
    # Not my_exit; too early in script
    exit 1
fi

# start: start off the log file
file_log="$dir_inst_files/$file_log"
echo_header                                      >> "$file_log"
echo_version                                     >> "$file_log"
echo "$tag Installation started on: $start_date" >> "$file_log"
unamea=`uname -a`
echo "$tag System uname -a output:  $unamea"     >> "$file_log"
# end: start off the log file

#
# Utilities.
#

set_up_echo_n()
{
    if [ -z "`echo -n`" ]; then
        ECHO_N=-n
        ECHO_C=
    else
        ECHO_N=
        ECHO_C='\c'
    fi
}

echo_n()
{
    echo $ECHO_N "$@"$ECHO_C
}

set_up_pager()
{
    orig_LESS_opts="$LESS"
    for i in "$PAGER" less more; do
        ii=`which "$i" 2> /dev/null`
        if [ -f "$ii" -a -x "$ii" ]; then
            PAGER="$ii"
            return
        fi
    done
    PAGER="cat"
}

# create alternate temporary directory needed by FlexNET at runtime
set_up_var_tmp ()
{
    if [ ! -d /var/tmp ]; then
        mkdir /var/tmp 2> /dev/null
        chmod -R 777 /var/tmp 2> /dev/null  
        if [ ! -d /var/tmp ]; then
            echo "$tag unable to detect or create /var/tmp directory" >> "$file_log"
        fi
    fi
}

# create alternate temporary directory needed by FlexNET at runtime
set_up_usr_tmp ()
{
    if [ ! -d /usr/tmp ]; then
        mkdir /usr/tmp 2> /dev/null
        chmod -R 777 /usr/tmp 2> /dev/null  
        if [ ! -d /usr/tmp ]; then
            echo "$tag unable to detect or create /usr/tmp directory" >> "$file_log"
        fi
    fi
}

set_up_editor()
{
    for i in "$EDITOR" vi vim ex ed; do
        ii=`which "$i" 2> /dev/null`
        if [ -f "$ii" -a -x "$ii" ]; then
            EDITOR="$ii"
            return
        fi
    done
    echo "$tag Error: could not find an editor to use (EDITOR environment variable not set)" | tee -a "$file_log"
    EDITOR=
    return 0
}

#
# Messages and exit handlers.
#

# save state for future runs (see also setup() which defines what's in the state)
save_cfg_options()
{
    cat > "$dir_inst_files/$file_cfg" <<EOF
#!/bin/sh
dir_install_other="$dir_install_other"
dir_install="$dir_install"
file_lic_online="$file_lic_online"
file_lic_server="$file_lic_server"
mode_server_install="$mode_server_install"
mode_license_install="$mode_license_install"
mode_dir_install="$mode_dir_install"
EOF
}

further_info()
{
    echo "Further information is available in the documentation:"
    echo "    ${name_eula} - End User License Agreement"
    echo "    ${name_readme}, $name_howto - general installation information"
    echo "    $name_enduser - License Administration Guide"
    echo "and from http://www.flexerasoftware.com."
    echo
    echo "A detailed log of the installation process can be found in the file:"
    echo "        $file_log"
    echo "An installation can be [re]started from this directory."
    echo
    echo "If you have any questions or encountered any problems during this installation,"
    echo "please contact customer support at:"
    echo "        $support_www"
    echo
    echo "${package_attr}"
}

# $1 = exit status (0 for success)
my_exit()
{
    if [ -n "$1" ]; then
        ret="$1"
    else
        ret=1
    fi

    case "$ret" in
        quit_calling | int_calling ) # user requested quit
            ret=1
            do_further_inf=true
            do_save_cfg=true
            do_hr=true
        ;;
        help_calling ) # -help
            ret=1
            do_further_inf=true
            do_save_cfg=
            do_hr=
        ;;
        version_calling ) # -version
            ret=1
            do_further_inf=
            do_save_cfg=
            do_hr=
        ;;
        0 ) # normal exit
            do_further_inf=
            do_save_cfg=true
            do_hr=true
        ;;
        * ) # error exit
            do_further_inf=true
            do_save_cfg=true
            do_hr=true
        ;;
    esac

    if [ -n "$do_further_inf" ]; then
        echo | tee -a "$file_log"
        further_info
        further_info >> "$file_log"
    fi

    if [ -n "$do_save_cfg" ]; then save_cfg_options; fi

    # Don't use run_command_dev_null etc.; if this fails we can live with that
    if [ -f "$TMPDIR/$file_temp" ]; then /bin/rm -f "$TMPDIR/$file_temp" > /dev/null 2>&1; fi

    if [ -n "$do_hr" ]; then
        if [ -n "$file_log" ]; then
            echo_header | tee -a "$file_log"
        else
            echo_header
        fi
    fi

    interrupt_exit_enabled= # fixes OSF1 /bin/sh bug where my_exit() triggers int_handler(
    exit $ret
}

quit()
{
    ask "Do you really want to quit" yn n
    case "$answer" in
        n ) return ;;
    esac
    my_exit quit_calling
}

int_handler()
{
    if [ -z "$interrupt_exit_enabled" ]; then return; fi # fixes OSF1 /bin/sh bug where my_exit() triggers int_handler()
    echo | tee -a "$file_log"
    echo "$tag Warning: installation interrupted" | tee -a "$file_log"
    my_exit int_calling
}

do_help()
{
    echo
    echo_version
    echo "Usage: $my_script_name <options>"
    echo "Options:"
    echo "    -help             display this message"
    echo "    -nowork           do not actually install, just display installer actions"
    echo "    -verbose          display installer actions while installing"
    echo "    -version          display installer version and exit"
    echo "    -server_license   run installation assuming a valid server license is present"
    my_exit help_calling
}

#
# More utilities.
#

# $1 = the number of the screen that should be presented next
# $2 = title to display at bottom of PAGER screens
run_pager()
{
    if [ -f "$PAGER" -a -x "$PAGER" ]; then
        my_less_title=
        case "$PAGER" in
            */less )
                my_less_title="[spacebar to continue, q to quit, h for help]"
                if [ -n "$2" ]; then
                    my_less_title="$2  $my_less_title"
                fi
                if [ -n "$orig_LESS_opts" ]; then
                    LESS="$orig_LESS_opts -P$my_less_title"
                else
                    LESS="-P$my_less_title"
                fi
                export LESS
            ;;
        esac
        $PAGER "$1"
        if [ -n "$my_less_title" ]; then
            LESS="$orig_LESS_opts"
            export LESS
        fi
    else
        # This should never happen due to set_up_pager() having a default.
        echo "$tag Error: could not find a pager to use (PAGER environment variable not set)" | tee -a "$file_log"
        my_exit 1
    fi
}

# $1 = the number of the screen that should be presented next
go_to_screen()
{
    if [ -z "$1" ]; then
        echo "$tag Internal Error: go_to_screen() screen not specified" | tee -a "$file_log"
        my_exit 1
    fi
    screen_prev="$screen_next"
    screen_next="$1"
}

# $1   = error message to use on failure
# $2.. = command string to run
# $failed = returned on failure
# if $verbose_command is set the command will be printed before being executed
# if $do_work is not set the command won't actually be executed
run_command_dev_null()
{
    local errinfo="$1"
    shift
    failed=
    if [ -z "$errinfo" ]; then
        echo "$tag Internal Error: no message specified in case of command failure" | tee -a $file_log
        my_exit 1
    fi
    if [ -n "$verbose_command" ]; then echo "$tag $@" | tee -a "$file_log"; fi
    if [ -n "$do_work" ]; then
        "$@" > /dev/null 2>&1
        if [ $? -ne 0 ]; then
            failed=true
            echo "$tag Error: $errinfo"              | tee -a "$file_log"
            echo "$tag Command: $@ > /dev/null 2>&1" | tee -a "$file_log"
            my_exit 1
        fi
    fi
}

# $1 = directory to cd to
# $2 = error message to use on failure
# $failed = returned on failure
# if $verbose_command is set the command will be printed before being executed
# if $do_work is not set the command won't actually be executed
run_command_cd()
{
    local errinfo="$1"
    shift
    if [ -n "$verbose_command" ]; then echo "$tag cd $@" | tee -a "$file_log"; fi
    if [ -n "$do_work" ]; then
        if [ -d "$@" ]; then
            cd "$@"
        else
            echo "$tag Error: $errinfo" | tee -a "$file_log"
            echo "$tag Command: cd $@"  | tee -a "$file_log"
            my_exit 1
            failed=true
        fi
    else
        failed=
    fi
}

# $1 and $2 are two strings for directories
# return $diff_dir if they really represent two different directories
is_different_directory()
{
    diff_dir=true
    if [ -n "$1" -a -n "$2" ]; then
        if [ -d "$1" -a -d "$2" ]; then
            if [ "$1" = "$2" ]; then
                diff_dir=
                return # definitely same
            else
                # try to tell if . and /dir are the same thing, etc.
                dirpush=`$PWDCMD`
                run_command_cd "could not cd to dir1 for is_different_directory" "$1"
                dir1=`$PWDCMD`
                run_command_cd "could not cd to dir2 for is_different_directory" "$2"
                dir2=`$PWDCMD`
                run_command_cd "could not cd to original directory for is_different_directory" "$dirpush"
                if [ "$dir1" = "$dir2" ]; then
                    diff_dir=
                    return # definitely same
                else
                    diff_dir=true
                    return # definitely different
                fi
            fi
        fi
    fi
}

# $1 = path
# return $can_make_dir if $1 doesn't already exist and if we think we can mkdir -p $1 successfully
can_make_directory()
{
    can_make_dir=

    if [ -z "$1" ]; then return; fi
    case "$1" in
        / | . | .. )  return ;;
        */ )          dir=`echo "$1" | sed -e 's/\/$//'` ;;
        * )           dir="$1" ;;
    esac

    if [ -f "$dir" ]; then return; fi  # we can't create a directory inside a file
    if [ -d "$dir" ]; then return; fi  # we can't create a directory that already exists

    while [ 1 ]; do
        get_file_directory_name "$dir"
        if [ -z "$file_dir" ]; then return; fi
        if [ -f "$file_dir" ]; then return; fi  # we can't create a directory inside a file
        if [ -d "$file_dir" ]; then
            check_if_writable_dir "$file_dir" "$file_name"
            if [ -z "$failed" ]; then can_make_dir=true; fi
            return
        fi
        dir="$file_dir"
    done
}

# $1 = question to ask
# $2 = possible answers
# $3 = default answer
# $answer = returned answer (always a single lower-case letter; or (fully-qualified) path for pq and pbq)
ask()
{
    case "$2" in
        yn | ynq | yq | ynbq )
            if [ -z "$3" ]; then
                echo "$tag Internal Error: ask() default not specified" | tee -a "$file_log"
                my_exit 1
            fi
        ;;
        eula )
            if [ -n "$3" ]; then
                echo "$tag Internal Error: ask() default should not be specified" | tee -a "$file_log"
                my_exit 1
            fi
        ;;
        pq | pbq ) ;;  # optional default value in these cases (i.e., a path)
        * )
            echo "$tag Internal Error: unknown ask() option: $2" | tee -a "$file_log"
            my_exit 1
        ;;
    esac

    answered=
    while [ -z "$answered" ]; do

        # Even though $choices is loop-invariant, set it up each time through, because if
        # quit() is called, and we don't reall quit, we'll come around again and $choices
        # will be messed up.  Having a function-local variable for $choices would fix this.
        case "$2" in
            yn )   choices=" ([y]es/[n]o)?" ;;
            ynq )  choices=" ([y]es/[n]o/[q]uit)?" ;;
            yq )   choices=" ([y]es/[q]uit)?" ;;
            ynbq ) choices=" ([y]es/[n]o/[b]ack/[q]uit)?" ;;
            pq )   choices=" (<path>/[q]uit):" ;;
            pbq )  choices=" (<path>/[b]ack/[q]uit):" ;;
            eula ) choices=" (accept/reject)?" ;;
            * )
                echo "$tag Internal Error: unknown ask() option: $2" | tee -a "$file_log"
                my_exit 1
            ;;
        esac
        if [ -n "$3" ]; then choices="${choices} [$3]"; fi

        echo                       | tee -a "$file_log"
        echo_n "$1" "$choices" " " | tee -a "$file_log"
        read answer
        answered="true"
        if [ -z "$answer" ]; then
            if [ -n "$3" ]; then
                answer="$3"
                echo "$answer" >> "$file_log"
            else
                echo "$answer" >> "$file_log"
                answered= ; continue
            fi
        else
            echo "$answer" >> "$file_log"
        fi
        case "$answer" in
            [yY] | [yY][eE][sS] )     answer="y" ;;
            [nN] | [nN][oO] )         answer="n" ;;
            [bB] | [bB][aA][cC][kK] ) answer="b" ;;
            [qQ] | [qQ][uU][iI][tT] ) answer="q" ;;
        esac

        case "$2" in
            yn )
                case "$answer" in
                    y | n ) ;;
                    * ) answered= ; continue ;;
                esac
            ;;
            ynq )
                case "$answer" in
                    y | n ) ;;
                    q ) quit ; answered= ; continue ;;
                    * ) answered= ; continue ;;
                esac
            ;;
            yq )
                case "$answer" in
                    y ) ;;
                    q ) quit ; answered= ; continue ;;
                    * ) answered= ; continue ;;
                esac
            ;;
            ynbq )
                case "$answer" in
                    y | n | b ) ;;
                    q ) quit ; answered= ; continue ;;
                    * ) answered= ; continue ;;
                esac
            ;;
            pq | pbq )
                case "$answer" in
                    b ) ;;
                    q ) quit ; answered= ; continue ;;
                    * )
                        # valid path; make sure path is fully-qualified before returning
                        if [ -n "`echo "$answer" | sed -e '/^\//d'`" ]; then
                            answer="$dir_orig/$answer"
                        fi
                    ;;
                esac
            ;;
            eula )
                case "$answer" in
                    accept ) ;;
                    reject ) quit ; answered= ; continue ;;
                    * ) answered= ; continue ;;
                esac
            ;;
            * )
                echo "$tag Internal Error: unknown ask() option: $2" | tee -a "$file_log"
                my_exit 1
            ;;
        esac
    done
}

#
# Setup and initialization.
#

# $1 = filename (one of $all_files)
# $mode = returned chmod mode for this file
get_install_file_mode()
{
    case "$1" in
        $name_script ) mode=740 ;;
        $name_lmgrd | $name_vendor |$name_vendor_actlib) mode=750 ;;
        $name_lmutil | $name_getip | $name_chklic | $name_chklic_actlib) mode=700 ;;
        $name_howto | $name_readme | $name_eula | $name_enduser ) mode=644 ;;
        * )
            echo "$tag Internal Error: unrecognized installation file: $i" | tee -a "$file_log"
            my_exit 1
        ;;
    esac
}

setup()
{
    screen_next=screen_copy_right
    screen_prev="$screen_next"
    set_up_echo_n

    set_up_var_tmp
    set_up_usr_tmp

    set_up_pager
    set_up_editor

    if [ -n "$verbose_command" ]; then
        # some environment debug dumps
        (
            echo "$tag Internal environment settings:"
            echo "$tag     TMPDIR = <$TMPDIR>"
            echo "$tag     PWDCMD = <$PWDCMD>"
            echo "$tag     PAGER  = <$PAGER>"
            echo "$tag     EDITOR = <$EDITOR>"
        ) | tee -a "$file_log"
    fi

    # saved/restored state (see also save_cfg_options() which saves this state)
    dir_install_other=
    dir_install=
    file_lic_online=
    file_lic_server=
    mode_server_install=
    if [ -n "$do_dir_inst_lic" ]; then
        mode_license_install=
    else
        mode_license_install=local
    fi
    mode_dir_install=
    # things in the state that shouldn't be saved/restored
    verbose=true
    use_no_license=
    file_lic_editor="$TMPDIR/$file_temp"

    # update state from saved values, if any
    if [ -f "$dir_inst_files/$file_cfg" ]; then
        . "$dir_inst_files/$file_cfg"
    fi

    # Expect $name_script and $all_files to be in $dir_inst_files, the directory where we were when we ran $name_script.
    # Check and make sure all the files are there; chmod them so we can run them if we need to.
    # Do chmod on $all_files in $dir_inst_files.
    for i in $all_files; do
        special_chklic_processing "$i"
        if [ -n "$special_chklic" ]; then
            run_command_dev_null_nolog "could not copy file to $dir_inst_files_is directory" /bin/cp "$special_chklic" "$dir_inst_files/$i"
        fi
        if [ ! -f "$dir_inst_files/$i" ]; then
            echo "$tag Error: could not find installation file in $dir_inst_files_is directory: $dir_inst_files/$i" | tee -a "$file_log"
            my_exit 1
        fi
        get_install_file_mode $i
        # I think this one can run even in -nowork mode to check out the license (leaving under do_work just for now)
        run_command_dev_null "chmod of installation file in $dir_inst_files_is directory failed" chmod $mode "$dir_inst_files/$i"
    done
    # I think this one can run even in -nowork mode to check out the license (leaving under do_work since it's platform-dependent)
    # early check that installation files actually run
    run_command_dev_null "installed software will not run; package might be for the wrong platform, or corrupted" "$dir_inst_files/$name_lmutil"
}

parse_arguments()
{
    while [ $# -gt 0 ]; do
        arg="$1"
        if [ -n "$arg" ]; then
            case "$arg" in
                -help )              do_help ;;
                -server_license )    assume_server_lic=true ;;
                -version )           echo_version ; my_exit version_calling ;;
                -nowork )            ;; # handled in pre_parse_arguments
                -verbose )           ;; # handled in pre_parse_arguments
                * )
                    echo "$tag Error: unknown command-line option: $arg" | tee -a "$file_log"
                    do_help
                ;;
            esac
        fi
        shift
    done
}

#
# Discovery routines and installer actions.
#

check_for_valid_platform()
{
    uname=`uname`
    case "$uname" in
        AIX | HP-UX | IRIX | IRIX64 | Linux | OSF1 )
            # recognized platform, regardless of OS version (at least we're not checking)
            return
        ;;
        Darwin )
            # recognised OS.
            # Now let us make sure about the architecture
            uname=`uname -m`
            case "$uname" in
                i?86 | x86 )
                    # Recognized Mac OS for IA32
                    return
                ;;
                x86_64 )
                    # Recognized Mac OS for Intel64 with 64 bit kernel mode
                    return
                ;;
            esac
        ;;
        SunOS )
            uname=`uname -r`
            case "$uname" in
                5* )
                    uname=`uname -m`
                    case "$uname" in
                        sun4* | i86pc )
                            # recognized SunOS for sparc or IA
                            return
                        ;;
                    esac
                ;;
            esac
        ;;
    esac
    echo "$tag Error: unknown platform: $unamea" | tee -a "$file_log"
    my_exit 1
}

# return LFD_HAD_ERRORS on errors
check_license()
{
    use_no_license=
    LFD_HAD_ERRORS=0
    LFD_SAW_VALID_LICENSES=0
    LFD_SAW_COUNTED_LICENSES=0

    if [ ! -f "$file_lic_server" ]; then
        ask "License file does not exist; do you wish to fix this" ynq y
        case "$answer" in
            n )
                echo | tee -a "$file_log"
                echo "$tag Warning: license server will not be configured; no server license file exists" | tee -a "$file_log"
                LFD_HAD_ERRORS=1
                use_no_license=true
                go_to_screen screen_installation_settings ; return # installation settings
            ;;
        esac
        # errors found in license; user said he wanted to fix it
        LFD_HAD_ERRORS=1
        go_to_screen screen_enter_license_data ; return # select license data
    fi

    if [ -n "$verbose_command" ]; then echo "$tag wc -l $file_lic_server | sed -e 's/^ *//' -e 's/ .*$//'" | tee -a "$file_log"; fi
    # I think this one can run even in -nowork mode to check out the license
    ###if [ -n "$do_work" ]; then
        file_lines=`wc -l "$file_lic_server" | sed -e 's/^ *//' -e 's/ .*$//'`
        if [ "$file_lines" -lt 2 ]; then
            ask "License file appears empty or malformed; do you wish to fix this" ynq y
            case "$answer" in
                n )
                    echo | tee -a "$file_log"
                    echo "$tag Warning: license server will not be configured; server license file is empty or malformed" | tee -a "$file_log"
                    LFD_HAD_ERRORS=1
                    use_no_license=true
                    go_to_screen screen_installation_settings ; return # installation settings
                ;;
            esac
            # errors found in license; user said he wanted to fix it
            LFD_HAD_ERRORS=1
            go_to_screen screen_enter_license_data ; return # select license data
        fi
    ###fi

    # check for valid vs. invalid licenses, licenses that require server, etc.
    if [ -n "$verbose_command" ]; then echo "$tag $dir_inst_files/$name_chklic -q -r -c$file_lic_server" | tee -a "$file_log"; fi
    if [ -n "$do_work" ]; then

        # Have to turn off INTEL_LMD_DEBUG around chklic if it goes to stderr.
        env_var_string=`env | grep "^INTEL_LMD_DEBUG="`
        chklic_debug_to_stderr=
        if [ -n "$env_var_string" ]; then
            save_INTEL_LMD_DEBUG="$INTEL_LMD_DEBUG"
            if [ -n "$INTEL_LMD_DEBUG" ]; then
                env_var_is_numeric=`expr $INTEL_LMD_DEBUG + 1 2> /dev/null`
                if [ -n "$env_var_is_numeric" ]; then
                    chklic_debug_to_stderr=true
                fi
            else
                chklic_debug_to_stderr=true
            fi
        fi
        if [ -n "$chklic_debug_to_stderr" ]; then
            INTEL_LMD_DEBUG=0
            export INTEL_LMD_DEBUG
        fi
        chklic_result=`"$dir_inst_files/$name_chklic" -q -r -c"$file_lic_server"`
        chklic_status=$?
        if [ -n "$chklic_debug_to_stderr" ]; then
            INTEL_LMD_DEBUG="$save_INTEL_LMD_DEBUG"
            export INTEL_LMD_DEBUG
        fi

        # decode bits out of $chklic_status and process them (lsb first)
        nexti="$chklic_status"
        LFD_HAD_ERRORS=`expr $nexti % 2` ; nexti=`expr $nexti / 2`
        if [ $LFD_HAD_ERRORS -ne 0 ]; then
            (
                echo "$tag Error: problems encountered while checking license file"
                echo "$tag Command: $dir_inst_files/$name_chklic -r -c$file_lic_server"
                echo "$tag Contents of license file:"
                cat "$file_lic_server"
            ) | tee -a "$file_log"

            ask "License file may be malformed, which could have caused the above problems; do you wish to fix this" ynq y
            case "$answer" in
                n )
                    echo | tee -a "$file_log"
                    echo "$tag Warning: license server will not be configured; server license file may be malformed" | tee -a "$file_log"
                    LFD_HAD_ERRORS=1
                    use_no_license=true
                    go_to_screen screen_installation_settings ; return # installation settings
                ;;
            esac
            # errors found in license; user said he wanted to fix it
            LFD_HAD_ERRORS=1
            go_to_screen screen_enter_license_data ; return # select license data
        fi
        LFD_SAW_VALID_LICENSES=`expr $nexti % 2` ; nexti=`expr $nexti / 2`
        if [ $LFD_SAW_VALID_LICENSES -eq 0 ]; then
            ask "License file appears to contain no valid licenses; do you wish to fix this" ynq y
            case "$answer" in
                n )
                    echo | tee -a "$file_log"
                    echo "$tag Warning: license server will not be configured; server license file contains no valid licenses" | tee -a "$file_log"
                    LFD_HAD_ERRORS=1
                    use_no_license=true
                    go_to_screen screen_installation_settings ; return # installation settings
                ;;
            esac
            # errors found in license; user said he wanted to fix it
            LFD_HAD_ERRORS=1
            go_to_screen screen_enter_license_data ; return # select license data
        fi
        LFD_SAW_COUNTED_LICENSES=`expr $nexti % 2` ; nexti=`expr $nexti / 2`
        if [ $LFD_SAW_COUNTED_LICENSES -eq 0 ]; then
            echo | tee -a "$file_log"
            echo "$tag Warning: license server will not be configured; server license file contains no counted licenses" | tee -a "$file_log"
            # do not go_to_screen screen_installation_settings etc. in this case; we still want to install the license file because it _is_ valid
        fi
    fi
}

# returns $server_running if server is running
check_server()
{
    server_running=
    # we can run $name_lmutil before install_files() because we installed it early in setup()
    if [ -n "$verbose_command" ]; then echo "$tag $dir_inst_files/$name_lmutil $name_lmstat -c $file_lic_server | egrep 'UP'" | tee -a "$file_log"; fi
    # I think this one can run even in -nowork mode to check out the license (leaving under do_work since it's platform-dependent)
    if [ -n "$do_work" ]; then
        server_stat=`"$dir_inst_files/$name_lmutil" "$name_lmstat" -c "$file_lic_server" | egrep 'UP'`
        case "$server_stat" in
            *UP* ) server_running=true ;;
        esac
    fi

    if [ -z "$server_running" ]; then
        # the server is not up now
        go_to_screen screen_start_server ; return # start license server
    else
        # the server is up now
        go_to_screen screen_refresh_server ; return # refresh license server
    fi
}

install_files()
{
    # actual files listed in $all_files
    case "$mode_dir_install" in
        other_mkdir )
            echo | tee -a "$file_log"
            echo "$tag Note: creating installation directory" | tee -a "$file_log"
            run_command_dev_null "could not create installation directory" mkdir -p "$dir_install"
        ;;
        current | other ) ;;
        * )
            echo "$tag Internal Error: unknown install directory mode: $mode_dir_install" | tee -a "$file_log"
            my_exit 1
        ;;
    esac

    echo | tee -a "$file_log"
    echo "$tag Note: installing files" | tee -a "$file_log"
    for i in $all_files; do
        case "$mode_dir_install" in
            current ) ;;
            other | other_mkdir )
                run_command_dev_null "could not remove previous installation file" /bin/rm -f "$dir_install/$i"
                run_command_dev_null "could not install file" /bin/cp "$dir_inst_files/$i" "$dir_install/$i"
            ;;
            * )
                echo "$tag Internal Error: unknown install directory mode: $mode_dir_install" | tee -a "$file_log"
                my_exit 1
            ;;
        esac
        get_install_file_mode $i
        run_command_dev_null "chmod of installation file failed" chmod $mode "$dir_install/$i"
    done

    echo | tee -a "$file_log"
    echo "$tag Note: making symbolic links for $name_lmutil" | tee -a "$file_log"
    # various aliases for $name_lmutil
    dirpush=`$PWDCMD`
    run_command_cd "could not cd to installation directory" "$dir_install"
    for i in "${all_links[@]}"; do
        run_command_dev_null "could not remove previous installation file" /bin/rm -f "$i"
        run_command_dev_null "could not make link of installation file" ln -s "$name_lmutil" "$i"
    done
    run_command_cd "could not cd to original directory" "$dirpush"
}

install_license()
{
    echo | tee -a "$file_log"
    echo "$tag Note: installing server license file" | tee -a "$file_log"
    case "$mode_license_install" in
        global )
            if [ -z "$do_dir_inst_lic" ]; then
                echo "$tag Internal Error: invalid license install mode: $mode_license_install" | tee -a "$file_log"
                my_exit 1
            fi
            run_command_dev_null "could not install license file" /bin/cp "$file_lic_server" "$dir_inst_lic/$file_inst_lic" 
            run_command_dev_null "could not chmod installed license file" chmod 444 "$dir_inst_lic/$file_inst_lic"
        ;;
        global_append )
            #
            # See where mode_license_install=global_append gets set for notes on why a pre-chmod is required.
            #
            if [ -z "$do_dir_inst_lic" ]; then
                echo "$tag Internal Error: invalid license install mode: $mode_license_install" | tee -a "$file_log"
                my_exit 1
            fi
            run_command_dev_null "could not chmod installed license file" chmod 666 "$dir_inst_lic/$file_inst_lic"
            if [ -n "$verbose_command" ]; then echo "$tag cat $file_lic_server >> $dir_inst_lic/$file_inst_lic" | tee -a "$file_log"; fi
            if [ -n "$do_work" ]; then
                cat "$file_lic_server" >> "$dir_inst_lic/$file_inst_lic"
            fi
            run_command_dev_null "could not chmod installed license file" chmod 444 "$dir_inst_lic/$file_inst_lic"
        ;;
        global_mkdir )
            if [ -z "$do_dir_inst_lic" ]; then
                echo "$tag Internal Error: invalid license install mode: $mode_license_install" | tee -a "$file_log"
                my_exit 1
            fi
            run_command_dev_null "could not create license directory" mkdir -p "$dir_inst_lic"
            run_command_dev_null "could not install license file" /bin/cp "$file_lic_server" "$dir_inst_lic/$file_inst_lic"
            run_command_dev_null "could not chmod installed license file" chmod 444 "$dir_inst_lic/$file_inst_lic"
        ;;
        global_not )
            if [ -z "$do_dir_inst_lic" ]; then
                echo "$tag Internal Error: invalid license install mode: $mode_license_install" | tee -a "$file_log"
                my_exit 1
            fi
        ;;
        local ) ;;
        * )
            echo "$tag Internal Error: unknown license install mode: $mode_license_install" | tee -a "$file_log"
            my_exit 1
        ;;
    esac
    run_command_dev_null "could not install local license file" /bin/cp "$file_lic_server" "$dir_install/$file_local_lic"
    run_command_dev_null "could not chmod installed local license file" chmod 644 "$dir_install/$file_local_lic"
}

make_server_start_rc_file()
{
    rc_cmd_for_echo=("$dir_install/$name_lmgrd" -c "$dir_install/$file_local_lic" -l "$dir_install/$file_server_log")
    rc_security_note="$tag Note: It is STRONGLY recommended not to start the server as root for security reasons."

    echo | tee -a "$file_log"
    if [ -n "$do_start_file_rc" ]; then
        (
            echo "$tag Note: the license server can be started by using this command:"
            echo "        $dir_install/$file_rc"
            echo "This command can be invoked from /etc/rc.d (etc.) during system start-up to start the server."
            echo "$rc_security_note"
        ) | tee -a "$file_log"
        if [ -n "$verbose_command" ]; then echo "$tag (create $dir_install/$file_rc)" | tee -a "$file_log"; fi
    else
        (
            echo "$tag Note: the license server can be started by using these commands:"
            echo "        cd $dir_install"
            echo "        ${rc_cmd_for_echo[@]}"
            echo "$rc_security_note"
            echo
            echo "$tag Note: a copy of these commands is being written to the file:"
            echo "        $dir_install/$file_rc"
            echo "This file can be invoked from /etc/rc.d (etc.) during system start-up to start the server."
        ) | tee -a "$file_log"
        if [ -n "$verbose_command" ]; then echo "$tag (echo above commands to $dir_install/$file_rc)" | tee -a "$file_log"; fi
    fi

    if [ -n "$do_work" ]; then
        cat > "$dir_install/$file_rc" <<EOF
#!/bin/sh
echo "$rc_security_note"
if [ -d "$dir_install" ]; then
    cd "$dir_install"
    $(printf '"%s" ' "${rc_cmd_for_echo[@]}") > /dev/null 2>&1
    if [ \$? -ne 0 ]; then
        echo "$tag Error: $dir_install/${file_rc}: could not start license server"
        echo "$tag Command: ${rc_cmd_for_echo[@]} > /dev/null 2>&1"
        exit 1
    fi
else
    echo "$tag Error: $dir_install/${file_rc}: could not cd to server directory $dir_install"
    exit 1
fi
exit 0
EOF
    fi
    run_command_dev_null "could not chmod license server start-up file" chmod 755 "$dir_install/$file_rc"
}

install_server()
{
    case "$mode_server_install" in
        no_counted )
            echo | tee -a "$file_log"
            echo "$tag Note: license server not started; no counted licenses in license file" | tee -a "$file_log"
        ;;
        start )
            make_server_start_rc_file
            echo | tee -a "$file_log"
            if [ -n "$do_start_file_rc" ]; then
                echo "$tag Note: starting license server now by using the above command" | tee -a "$file_log"
                run_command_dev_null "could not start license server" "$dir_install/$file_rc"
            else
                echo "$tag Note: starting license server now by using the above commands" | tee -a "$file_log"
                dirpush=`$PWDCMD`
                run_command_cd "could not cd to installation directory" "$dir_install"
                run_command_dev_null "could not start license server" "${rc_cmd_for_echo[@]}"
            fi
            # wait a few seconds for server start-up, then check logs to see how it did
            run_command_dev_null "sleep command failed" sleep 3
            for badword in "exiting" "can't" "cannot" "kill" "error" "invalid"; do
                grep -i "$badword" "$dir_install/$file_server_log" > /dev/null 2>&1
                if [ $? -eq 0 ]; then
                    # bad keyword found; server start-up must have failed
                    echo "$tag Error: license server failed to start" | tee -a "$file_log"
                    my_exit 1
                fi
            done
            if [ -z "$do_start_file_rc" ]; then
                run_command_cd "could not cd to original directory" "$dirpush"
            fi
        ;;
        make_start_rc_file )
            make_server_start_rc_file
        ;;
        reread )
            make_server_start_rc_file
            (
                echo
                echo "$tag Note: refreshing license server now by using this command:"
                echo "        $dir_install/$name_lmutil $name_lmreread -c $dir_install/$file_local_lic"
            ) | tee -a "$file_log"
            run_command_dev_null "could not refresh license server" "$dir_install/$name_lmutil" "$name_lmreread" -c "$dir_install/$file_local_lic"
        ;;
        no_reread )
            make_server_start_rc_file
            echo | tee -a "$file_log"
            echo "$tag Warning: license server not refreshed; this may result in future license check-out problems" | tee -a "$file_log"
        ;;
        * )
            echo "$tag Internal Error: unknown server install mode: $mode_server_install" | tee -a "$file_log"
            my_exit 1
        ;;
    esac
}

perform_installation()
{
    install_files
    if [ -n "$use_no_license" ]; then
        make_server_start_rc_file
    else
        install_license
        install_server
    fi
}

#
# Screens for each step in install process.
#

# $1 = title string
# $2 means just print title to stdout not log file
title()
{
    if [ -n "$2" ]; then
        echo_header
        echo "$tag $1 $tag"
    else
        echo_header | tee -a "$file_log"
        echo "$tag $1 $tag" | tee -a "$file_log"
    fi
}

msg_copy_right()
{
    # NOTE: $verbose does not affect this message (it contains the copyright notice) and because $verbose is not set until screen_verbose_message
    echo
    echo "$copyright_notice"
    echo "The ${package_name} is furnished under a license and"
    echo "may be used and copied only in accordance with the terms of said license."
    echo
    echo "This package utilizes Flexera Software FLEXnet* license management software."
    echo "Copyright (C) Flexera Software, Inc.  All Rights Reserved."
    echo
    echo "This script installs the ${package_name}, which consists"
    echo "of a license server and related utilities.  The $name_lmgrd and $name_vendor"
    echo "license server daemons are VERSION 11.12.0."
    echo
    echo "You may quit or ^C this script at any time and re-install later."
    echo
    echo "${package_attr}"
}

screen_copy_right()
{
    title "Installing ${package_name}"
    msg_copy_right | tee -a "$file_log"
    ask "Do you wish to begin the installation process" yq y
    go_to_screen screen_eula ; return # continue
}

msg_eula()
{
    # NOTE: $verbose does not affect this message (it contains the copyright notice) and because $verbose is not set until screen_verbose_message
    echo
    echo "You must accept the End User License Agreement in order to proceed"
    echo "with the installation of the ${package_name}."
}

screen_eula()
{
    title "Displaying End User License Agreement" stdout_only
    sleep 3
    run_pager "$dir_inst_files/$name_eula" "End User License Agreement"

    title "Accept End User License Agreement"
    msg_eula | tee -a "$file_log"
    echo >> "$file_log" ; cat $dir_inst_files/$name_eula >> "$file_log"
    ask "Do you accept the End User License Agreement" eula
    go_to_screen screen_verbose_message ; return # continue
}

msg_verbose_message()
{
    # NOTE: $verbose does not affect this message since $verbose is just being set here
    echo
    echo "By default, the installer prints verbose messages describing each"
    echo "installation option or question asked."
}

screen_verbose_message()
{
    title "Verbose Messages"
    msg_verbose_message | tee -a "$file_log"
    ask "Do you wish to see verbose messages" ynbq y
    case "$answer" in
        b ) go_to_screen screen_eula ; return ;; # back
        y ) verbose=true ;;
        n ) verbose= ;;
    esac
    go_to_screen screen_select_install_location ; return # continue
}

msg_select_install_location()
{
    if [ "$dir_inst_files_is" = "temporary" ]; then
        echo
        echo "NOTE:"
        echo "The directory in which the installation was started was not writable,"
        echo "so the installation files were copied to a $dir_inst_files_is directory:"
        echo "        $dir_inst_files"
        echo
        echo "It is strongly recommended, then, that the installation files be copied"
        echo "to and installed in some other, more permanent, directory, rather than"
        echo "installing them in the $dir_inst_files_is directory."
    elif [ -n "$verbose" ]; then
        echo
        echo "By default, the installation is performed in the $dir_inst_files_is directory:"
        echo "        $dir_inst_files"
        echo
        echo "which contains the installation files.  These files may also, however,"
        echo "be copied to and installed in some other directory."
    fi
}

screen_select_install_location()
{
    mode_dir_install=

    title "Select Installation Location"
    msg_select_install_location | tee -a "$file_log"
    if [ "$dir_inst_files_is" = "temporary" ]; then
        ask "Install software in $dir_inst_files_is directory" ynbq n
    else
        ask "Install software in $dir_inst_files_is directory" ynbq y
    fi
    case "$answer" in
        b ) go_to_screen screen_verbose_message ; return ;; # back
        y )
            mode_dir_install=current
            dir_install="$dir_inst_files"
            if [ "$dir_inst_files_is" = "temporary" ]; then
                echo | tee -a "$file_log"
                echo "NOTE: the software will be installed in the above $dir_inst_files_is directory." | tee -a "$file_log"
            fi
            go_to_screen screen_enter_license_data ; return # select license data
        ;;
        n ) mode_dir_install=other ; go_to_screen screen_enter_install_dir ; return ;; # enter install directory name
    esac
}

msg_enter_install_dir()
{
    if [ -n "$verbose" ]; then
        echo
        echo "Please enter the path to the directory in which you wish to"
        echo "install the license server software.  The installed software will"
        echo "operate from the selected installation directory.  Note, however,"
        echo "that the installation log will be left in the $dir_inst_files_is directory"
        echo "where the installation was started."
    fi
}

screen_enter_install_dir()
{
    title "Enter Installation Directory"
    msg_enter_install_dir | tee -a "$file_log"
    while [ 1 ]; do
        ask "Enter path to directory in which to install software" pbq "$dir_install_other"
        answerd="$answer"
        case "$answer" in
            b ) go_to_screen screen_select_install_location ; return ;; # back
        esac
        # keep going around until we get a valid answer
        if [ -z "$answer" ]; then continue; fi # empty answer
        if [ -f "$answer" ]; then
            echo "$tag Error: directory specified already exists as a file" | tee -a "$file_log"
            continue
        fi
        if [ -d "$answer" ]; then
            check_if_writable_dir "$answer" "$file_temp_wdtest"
            if [ -n "$failed" ]; then
                echo "$tag Error: directory specified exists, but is not writable" | tee -a "$file_log"
                continue
            fi
            is_different_directory "$answer" "$dir_inst_files"
            if [ -z "$diff_dir" ]; then
                echo "$tag Error: directory specified is same as $dir_inst_files_is directory" | tee -a "$file_log"
                continue
            fi
            ask "Directory specified already exists; do you wish to overwrite any existing installation there" ynbq y
            case "$answer" in
                b | n ) continue ;; # go around again
            esac
            break # valid $answer
        else
            can_make_directory "$answer"
            if [ -n "$can_make_dir" ]; then
                ask "Directory specified does not exist; do you wish to create it" ynbq y
                case "$answer" in
                    b | n ) continue ;; # go around again
                esac
                mode_dir_install=other_mkdir ; break # valid $answer
            else
                echo "$tag Error: directory specified does not exist and cannot be created" | tee -a "$file_log"
            fi
            continue
        fi
    done
    dir_install_other="$answerd"
    dir_install="$dir_install_other"
    go_to_screen screen_enter_license_data ; return # select license data
}

msg_enter_license_data()
{
    if [ -n "$verbose" ]; then
        echo
        echo "Enter license data if you have licenses for your software products that"
        echo "may require a license server.  A server is required if licenses contain"
        echo "SERVER lines that specify the current machine as the server.  If you are"
        echo "unsure if your licenses require a server, enter the license data, and the"
        echo "installation script will determine if a server may be required.  If you"
        echo "do not enter license data, the license server cannot be configured, but"
        echo "the license server daemons and utilities will still be installed, and"
        echo "the server can be started later if desired."
    fi
}

screen_enter_license_data()
{
    use_no_license=

    title "Enter License Data"
    msg_enter_license_data | tee -a "$file_log"
    ask "Do you wish to enter license data" ynbq y
    case "$answer" in
        b ) go_to_screen screen_select_install_location ; return ;; # select installation location
        y ) go_to_screen screen_select_license_data ; return ;; # select license data
        n ) use_no_license=true ; go_to_screen screen_installation_settings ; return ;; # installation settings
    esac
}

msg_select_license_data()
{
    if [ -n "$verbose" ]; then
        echo
        echo "The license server must be configured to use a particular license"
        echo "file.  If the license data to be used with the license server is"
        echo "already stored in a file, which is available online now, this"
        echo "license data may be configured directly for use with the server."
        echo "If the license data is not stored in a file, an editor will be"
        echo "invoked so that you may enter the license data manually.  The"
        echo "license data used may be from a new license, received with your"
        echo "software, or from an existing, already-installed license file."
        echo
        echo "In any case, a copy of the license data to be used with the license"
        echo "server will be placed in the local license file:"
        echo "        $dir_install/$file_local_lic"
        echo "during the actual installation process.  This local license file"
        echo "will then be used when actually starting up the license server."
    fi
}

screen_select_license_data()
{
    title "Select License Data"
    msg_select_license_data | tee -a "$file_log"
    ask "Is the license data to be used stored in a file" ynbq y
    case "$answer" in
        b ) go_to_screen screen_enter_license_data ; return ;; # enter license data
        y ) go_to_screen screen_enter_license_path ; return ;; # enter server license file name
        n ) go_to_screen screen_enter_license_via_editor ; return ;; # editor input
    esac
}

msg_enter_license_path()
{
    if [ -n "$verbose" ]; then
        echo
        echo "Please enter the path and name of the file containing the"
        echo "license data you wish to use with the license server.  This"
        echo "license data used may be from a new license, received with your"
        echo "software, or from an existing, already-installed license file."
    fi
}

screen_enter_license_path()
{
    title "Enter Server License File Name"
    msg_enter_license_path | tee -a "$file_log"
    while [ 1 ]; do
        ask "Enter path/name of license file to be used" pbq "$file_lic_online"
        case "$answer" in
            b ) go_to_screen screen_enter_license_data ; return ;; # back
        esac
        # keep going around until we get a valid answer
        if [ -z "$answer" ]; then continue; fi # empty answer
        if [ ! -f "$answer" ]; then
            echo "$tag Error: license file path/name does not exist" | tee -a "$file_log"
            continue
        fi
        get_file_directory_name "$answer"
        if [ -z "$file_dir" -o -z "$file_name" ]; then
            echo "$tag Internal Error: could not separate license file path/name" | tee -a "$file_log"
            continue
        fi
        if [ "$file_name" = "$file_local_lic" ]; then
            is_different_directory "$file_dir" "$dir_install"
            if [ -z "$diff_dir" ]; then
                echo "$tag Error: license file path/name cannot be same as local license file $dir_install/$file_local_lic" | tee -a "$file_log"
                continue
            fi
        fi
        break # valid $answer
    done
    file_lic_online="$answer"
    file_lic_server="$file_lic_online"
    go_to_screen screen_display_license_data ; return # displaying selected license data
}

msg_enter_license_via_editor()
{
    if [ -n "$verbose" ]; then
        echo
        echo "An editor will now be started so that you can enter your license data manually."
    fi
}

screen_enter_license_via_editor()
{
    title "Enter Server License Data Via Editor"
    msg_enter_license_via_editor | tee -a "$file_log"
    if [ -f "$EDITOR" -a -x "$EDITOR" ]; then
        sleep 3
        $EDITOR "$file_lic_editor"
        if [ -e "$file_lic_editor" ]; then
            file_lic_server="$file_lic_editor"
            go_to_screen screen_display_license_data ; return # displaying selected license data
        else
            echo "$tag Error: could not find the license file $file_lic_editor edited via $EDITOR" | tee -a "$file_log"
            sleep 3
            go_to_screen screen_select_license_data ; return # select license data
        fi
        go_to_screen screen_display_license_data ; return # displaying selected license data
    else
        echo "$tag Error: could not find an editor to use (EDITOR environment variable not set)" | tee -a "$file_log"
        go_to_screen screen_select_license_data ; return # select license data
    fi
}

msg_display_license_data()
{
    if [ -n "$verbose" ]; then
        echo
        echo "You have requested that license data from the following file:"
        echo "        $file_lic_server"
        echo
        echo "be used with the installed license server, which contains the"
        echo "license data shown here."
        echo
        echo "A copy of this license data will be placed in the local license"
        echo "file:"
        echo "        $dir_install/$file_local_lic"
        echo "during the actual installation process.  This local license file"
        echo "will then be used when actually starting up the license server."
    else
        echo
        echo "A copy of the license data shown here will be placed in the file:"
        echo "        $dir_install/$file_local_lic"
        echo "which will then be used when actually starting up the license server."
    fi
}

screen_display_license_data()
{
    mode_server_install=

    title "Displaying Selected License Data" stdout_only
    sleep 3
    run_pager "$file_lic_server" "Selected License Data"

    title "Validate Server License Data"
    msg_display_license_data | tee -a "$file_log"
    echo >> "$file_log" ; cat "$file_lic_server" >> "$file_log"
    ask "Is this the correct license data" ynbq y
    case "$answer" in
        b ) go_to_screen screen_enter_license_data ; return ;; # select license data
        n ) go_to_screen screen_enter_license_data ; return ;; # select license data
    esac
    if [ -n "$assume_server_lic" ]; then
        # This is mostly "just in case" check_license() or chklic has a bug.
        # Assume we had LFD_SAW_COUNTED_LICENSES && !LFD_HAD_ERRORS and proceed.
        check_server
        return # go_to_screen was done in check_server()
    fi
    check_license
    if [ $LFD_HAD_ERRORS -ne 0 ]; then
        return # go_to_screen was done in check_license()
    elif [ $LFD_SAW_COUNTED_LICENSES -ne 0 ]; then
        check_server
        return # go_to_screen was done in check_server()
    else
        mode_server_install="no_counted"
        if [ -n "$do_dir_inst_lic" ]; then
            go_to_screen screen_install_lic_file ; return # install license file
        else
            go_to_screen screen_installation_settings ; return # installation settings
        fi
    fi
}

msg_start_server()
{
    if [ -n "$verbose" ]; then
        echo
        echo "A license server is apparently not already running."
        echo "The license server can be started as part of the installation"
        echo "process.  However, this may not be particularly useful because"
        echo "a system-administrator would need to configure /etc/rc.d (etc.)"
        echo "so that the server is re-started at system boot-time."
    fi
}

screen_start_server()
{
    title "Start License Server"
    msg_start_server | tee -a "$file_log"
    ask "The license server is apparently not running; do you wish to start it" ynbq n
    case "$answer" in
        b ) go_to_screen screen_display_license_data ; return ;; # validate server license data
        y ) mode_server_install="start" ;;
        n ) mode_server_install="make_start_rc_file" ;;
    esac
    if [ -n "$do_dir_inst_lic" ]; then
        go_to_screen screen_install_lic_file ; return # install license file
    else
        go_to_screen screen_installation_settings ; return # installation settings
    fi
}

msg_refresh_server()
{
    if [ -n "$verbose" ]; then
        echo
        echo "A license server is apparently already running.  The"
        echo "server must be refreshed if it is to utilize the license"
        echo "file data selected during this installation process."
    fi
}

screen_refresh_server()
{
    title "Refresh License Server"
    msg_refresh_server | tee -a "$file_log"
    ask "The license server is apparently running; do you wish to refresh it" ynbq y
    case "$answer" in
        b ) go_to_screen screen_display_license_data ; return ;; # validate license server data
        y ) mode_server_install="reread" ;;
        n ) mode_server_install="no_reread" ;;
    esac
    if [ -n "$do_dir_inst_lic" ]; then
        go_to_screen screen_install_lic_file ; return # continue (to install license file)
    else
        go_to_screen screen_installation_settings ; return # continue (to installation settings)
    fi
}

msg_install_lic_file()
{
    if [ -n "$verbose" ]; then
        echo
        echo "A copy of the license data to be used will be placed in the local"
        echo "license file:"
        echo "        $dir_install/$file_local_lic"
        echo
        echo "This local license file will be used to actually start up the license"
        echo "server (if applicable).  In addition, a copy of this license file may"
        echo "be placed in the default license directory in:"
        echo "        $dir_inst_lic/$file_inst_lic"
        echo
        echo "for use by your licensed software products."
    fi
}

screen_install_lic_file()
{
    if [ -z "$do_dir_inst_lic" ]; then
        echo "$tag Internal Error: invalid screen: $screen_next" | tee -a "$file_log"
        my_exit 1
    fi

    mode_license_install=

    title "Install License File"
    msg_install_lic_file | tee -a "$file_log"
    while [ 1 ]; do
        ask "Do you wish to install a copy of the license in $dir_inst_lic" ynbq y
        case "$answer" in
            b ) go_to_screen screen_display_license_data ; return ;; # validate license server data
            n ) mode_license_install="global_not" ; go_to_screen screen_installation_settings ; return ;; # continue
        esac
        # keep going around until we get a valid answer
        if [ -d "$dir_inst_lic/$file_inst_lic" ]; then
            echo "$tag Error: license file $dir_inst_lic/$file_inst_lic already exists as a directory" | tee -a "$file_log"
            continue
        fi
        check_if_writable_dir "$dir_inst_lic" "$file_temp_wdtest"
        if [ -z "$failed" -a -f "$dir_inst_lic/$file_inst_lic" ]; then
            #
            # If we created $dir_inst_lic/$file_inst_lic in the first place, then we left it with chmod 444.
            # This will make it appear non-writable at this point, but it has to be writable to append to it.
            # However, the only way we can find out if chmod 666 will work is to actually do that chmod, and
            # that's against the installer's philosophy of ask questions first and do work at the end.  So,
            # go ahead even if it's not writable here, and have install_license() try to do the appropriate
            # pre-chmod and post-chmod so the append will hopefully work.
            #
            ask "License file $dir_inst_lic/$file_inst_lic already exists; do you wish to append to it" ynbq y
            case "$answer" in
                b | n ) continue ;; # go around again
            esac
            mode_license_install="global_append"
            go_to_screen screen_installation_settings ; return # continue
        fi
        if [ -d "$dir_inst_lic" ]; then
            check_if_writable_dir "$answer" "$file_temp_wdtest"
            if [ -z "$failed" ]; then break; fi # valid answer
            echo "$tag Error: license directory $dir_inst_lic exists, but is not writable" | tee -a "$file_log"
            continue
        else
            can_make_directory "$dir_inst_lic"
            if [ -n "$can_make_dir" ]; then
                ask "License directory $dir_inst_lic does not exist; do you wish to create it" ynbq y
                case "$answer" in
                    b | n ) continue ;; # go around again
                esac
                mode_license_install="global_mkdir"
                go_to_screen screen_installation_settings ; return # continue
            else
                echo "$tag Error: license directory $dir_inst_lic does not exist and cannot be created" | tee -a "$file_log"
            fi
            continue
        fi
    done
    mode_license_install="global"
    go_to_screen screen_installation_settings ; return # continue
}

msg_installation_settings()
{
    # NOTE: $verbose does not affect this message (it contains the installation settings to be approved)
    echo
    echo "You selected the following choices for installation parameters.  Please"
    echo "review this list for any changes/corrections that need to be made."
    echo
    case "$mode_dir_install" in
        current )
            echo "        Installation Directory     $dir_install ($dir_inst_files_is directory)" # $dir_inst_files
        ;;
        other )
            # $dir_install_other
            echo "        Installation Directory     $dir_install (not $dir_inst_files_is directory; directory exists)"
        ;;
        other_mkdir )
            # $dir_install_other
            echo "        Installation Directory     $dir_install (not $dir_inst_files_is directory; create directory)"
        ;;
        * )
            echo "$tag Internal Error: unknown install directory mode: $mode_dir_install"
            my_exit 1
        ;;
    esac
    if [ -n "$use_no_license" ]; then
        echo "        Server License File        (none; do not configure server)"
    else
        if [ "$file_lic_server" = "$file_lic_online" ]; then
            echo "        Server License File        $file_lic_server"
        else
            echo "        Server License File        (entered manually via editor)"
        fi
        case "$mode_license_install" in
            global )
                if [ -z "$do_dir_inst_lic" ]; then
                    echo "$tag Internal Error: invalid license install mode: $mode_license_install"
                    my_exit 1
                fi
                echo "        Install Server License     (in $dir_inst_lic/$file_inst_lic)"
                echo "                                   (and locally in $dir_install/$file_local_lic)"
            ;;
            global_append )
                if [ -z "$do_dir_inst_lic" ]; then
                    echo "$tag Internal Error: invalid license install mode: $mode_license_install"
                    my_exit 1
                fi
                echo "        Install Server License     (append to $dir_inst_lic/$file_inst_lic)"
                echo "                                   (and locally in $dir_install/$file_local_lic)"
            ;;
            global_mkdir )
                if [ -z "$do_dir_inst_lic" ]; then
                    echo "$tag Internal Error: invalid license install mode: $mode_license_install"
                    my_exit 1
                fi
                echo "        Install Server License     (in $dir_inst_lic/$file_inst_lic; create directory)"
                echo "                                   (and locally in $dir_install/$file_local_lic)"
            ;;
            global_not )
                if [ -z "$do_dir_inst_lic" ]; then
                    echo "$tag Internal Error: invalid license install mode: $mode_license_install"
                    my_exit 1
                fi
                echo "        Install Server License     (locally in $dir_install/$file_local_lic only)"
            ;;
            local )
                echo "        Install Server License     (locally in $dir_install/$file_local_lic)"
            ;;
            * )
                echo "$tag Internal Error: unknown license install mode: $mode_license_install"
                my_exit 1
            ;;
        esac
        case "$mode_server_install" in
            no_counted ) ;;
            start | make_start_rc_file )  echo "        Server Current State       (not running)" ;;
            reread | no_reread )          echo "        Server Current State       (running)" ;;
            * )
                echo "$tag Internal Error: unknown server install mode: $mode_server_install"
                my_exit 1
            ;;
        esac
        case "$mode_server_install" in
            no_counted )         echo "        Server Configuration       (do not start server; no counted licenses in license file)" ;;
            start )              echo "        Server Configuration       (start server on installation)" ;;
            make_start_rc_file ) echo "        Server Configuration       (do not start server)" ;;
            reread )             echo "        Server Configuration       (refresh server with license file)" ;;
            no_reread )          echo "        Server Configuration       (do not refresh server with license file)" ;;
            * )
                echo "$tag Internal Error: unknown server install mode: $mode_server_install"
                my_exit 1
            ;;
        esac
    fi
}

screen_installation_settings()
{
    title "Installation Settings"
    msg_installation_settings | tee -a "$file_log"
    ask "Are the above settings ok" ynbq y
    case "$answer" in
        b )
            if [ -n "$use_no_license" ]; then
                go_to_screen screen_enter_license_data ; return # back
            elif [ -n "$do_dir_inst_lic" ]; then
                go_to_screen screen_install_lic_file ; return # back (to install license file)
            else
                # do not go to $screen_prev and loop; instead go back to beginning
                go_to_screen screen_copy_right ; return # back (to the begining)
            fi
        ;;
        y ) go_to_screen screen_begin_install ; return ;; # begin installation
        n ) go_to_screen screen_select_install_location ; return ;; # select installation location
    esac
}

msg_begin_install()
{
    if [ -n "$verbose" ]; then
        echo
        echo "You are now ready to begin actually installing the license server and"
        echo "utilities.  Go back to make any changes to your installation settings,"
        echo "or quit if you wish to install at a later time.  If you choose to"
        echo "proceed, the actual installation process will begin."
    fi
}

screen_begin_install()
{
    title "Begin Installation"
    msg_begin_install | tee -a "$file_log"
    ask "Do you wish to begin installing now" ynbq y
    case "$answer" in
        b ) go_to_screen screen_installation_settings ; return ;; # back
        n ) go_to_screen screen_select_install_location ; return ;; # select installation location
    esac
    go_to_screen screen_perform_install ; return # continue
}

msg_perform_install()
{
    if [ -n "$verbose" ]; then
        echo
        echo "The installation will now be performed.  Do not interrupt the installation"
        echo "process at this time.  Messages will be printed detailing the status of"
        echo "the installation process."
    fi
}

screen_perform_install()
{
    title "Perform Installation"
    msg_perform_install | tee -a "$file_log"
    perform_installation
    go_to_screen screen_install_complete ; return # continue
}

msg_install_complete()
{
    if [ -n "$verbose" ]; then
        echo
        further_info
    else
        echo
        echo "A detailed log of the installation process can be found in the file:"
        echo "        $file_log"
        echo "An installation can be [re]started from this directory."
    fi
}

screen_install_complete()
{
    title "Installation Completed Successfully"
    msg_install_complete | tee -a "$file_log"
    my_exit 0
}

#
# "Main program"
#

parse_arguments "$@"
setup

# Discovery

check_for_valid_platform

# User input and installer actions

while [ 1 ]; do
    $screen_next
done

# should not really get here
echo "$tag Internal Error: unexpected exit" | tee -a "$file_log"
my_exit 1

